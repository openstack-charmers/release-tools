#!/bin/bash -e
# Push and Publish a Single Charm to each of its Defined Series,
# from an already checked-out charm dir, where the desired git
# branch is already checked out.
#   - Take no action if env var CHARM_PUSH_DRY_RUN is True.
#   - Listen for Jenkins $WORKSPACE env var and use it if found.

branch="$2"
charm="$1"
series="precise trusty xenial"
usage="usage: push-and-publish-multi-series charmname <master||stable||stable/nn.nn>"
export cs_refs_published="$(mktemp)"

if [ -z "$charm" ] || [ -z "$branch" ]; then
    echo $usage
    exit 1
fi

# Override charm dir when driven by Jenkins.
# Otherwise, use cmd param provided.
if [ -n "$WORKSPACE" ]; then
    # Driven by Jenkins.
    charm_dir="$WORKSPACE/$charm"
else
    # Expect a local checkout in the current dir.
    charm_dir="$charm"
fi

# Locate metadata.yaml for charm
metadata=$(find $charm_dir -name "metadata.yaml")

# Auto-detect a series in metadata charm
if grep -q "^series:.*" $metadata; then
    # Push and publish for proper multi-series charms, where
    # series is declared in the metadata.yaml for cs: to interpret.
   . push-and-publish $charm multi $branch
else
    # Push and publish for all relevant series of the charms which
    # use the legacy simulated multiple series approach of pushing
    # to individual cs series spaces.
    for this_series in $series; do
        charms=$(cat $this_series.txt)
        for charm_check in $charms; do
            if [ "$charm_check" == "$charm" ]; then
                found=true
                # Source it to preserve BUILT_ASSET_DIR, etc.
                . push-and-publish $charm $this_series $branch
            fi
        done
    done

    # Fatal if not found
    if [ -z "$found" ]; then
        echo "$charm not found in defined lists.  No action taken."
        exit 1
    fi
fi

echo " . Charm store refs published:"
cat $cs_refs_published

if [[ -n "$WORKSPACE" ]]; then
  mv -v $cs_refs_published $WORKSPACE/cs_refs_published.txt
else
  rm -fv $cs_refs_published
fi
