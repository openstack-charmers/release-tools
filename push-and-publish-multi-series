#!/bin/bash -e
# Push and Publish a Single Charm to each of its Defined Series,
# from an already checked-out charm dir, where the desired git
# branch is already checked out.
#   - Take no action if env var CHARM_PUSH_DRY_RUN is True.
#   - Listen for Jenkins $WORKSPACE env var and use it if found.

branch="$2"
charm="$1"
series="precise trusty xenial"
usage="usage: push-and-publish-multi-series charmname <master||stable||stable/nn.nn>"
export cs_refs_published="$(mktemp)"

if [ -z "$charm" ] || [ -z "$branch" ]; then
    echo $usage
    exit 1
fi

# Push and publish for all relevant series of the charms which
# use the legacy simulated multiple series approach of pushing
# to individual cs series spaces.
for this_series in $series; do
    charms=$(cat $this_series.txt)
    for charm_check in $charms; do
        if [ "$charm_check" == "$charm" ]; then
            found=true
            # Source it to preserve BUILT_ASSET_DIR, etc.
            . push-and-publish $charm $this_series $branch
        fi
    done
done

# Push and publish for proper multi-series charms, where
# series is declared in the metadata.yaml for cs: to interpret.
if [ -z "$found" ]; then
    charms=$(cat multi.txt)
    for charm_check in $charms; do
        if [ "$charm_check" == "$charm" ]; then
            found=true
            echo " . Handling $charm as a proper multi-series charm"
            # Source it to preserve BUILT_ASSET_DIR, etc.
            . push-and-publish $charm multi $branch
        fi
    done
fi

echo " . Charm store refs published:"
cat $cs_refs_published

if [[ -n "$WORKSPACE" ]]; then
  mv -v $cs_refs_published $WORKSPACE/cs_refs_published.txt
else
  rm -fv $cs_refs_published
fi

# Fatal if not found
if [ -z "$found" ]; then
    echo "$charm not found in defined lists.  No action taken."
    exit 1
fi
